<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>yaproom (official)</title>
  <style>
    /* ----------------------------------------
       1) Base Styles (Light Mode by default)
       ---------------------------------------- */
    body {
      font-family: Arial, sans-serif; /* Fallback font */
      margin: 10px;
      background: #f7f7f7;
      color: #000;
      transition: background 0.3s, color 0.3s, font-family 0.3s;
    }

    /* Rounded corners for UI elements */
    #loginDiv, #chatDiv, #settingsDiv,
    #messages, #dmMessages, #dm2Messages, #dm3Messages,
    textarea, button, select {
      border-radius: 8px; 
    }

    #loginDiv, #chatDiv, #settingsDiv {
      max-width: 400px;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }

    #chatDiv {
      display: none; /* Hidden until user enters or logs in */
    }
    #settingsDiv {
      display: none; /* Hidden until the "Settings" button is clicked */
    }

    #messages {
      list-style-type: none;
      padding: 0;
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 10px;
      border: 1px solid #ddd;
    }
    #messages li {
      padding: 8px;
      border-bottom: 1px solid #eee;
      margin: 0 4px;
    }

    /* If user is an account, color the name in blue by default; if anon, black. */
    .account-user {
      color: rgb(74, 148, 218);
      font-weight: bold;
    }
    .anonymous-user {
      color: #000;
      font-weight: normal;
    }

    /* Special style for broadcast messages. */
    .broadcast-msg {
      background: #ffeb3b;
      color: #000;
      font-weight: bold;
      padding: 4px;
      border-radius: 4px;
    }

    /* Typing status area */
    #typingStatus {
      color: #777;
      font-style: italic;
      margin-bottom: 10px;
      min-height: 18px; 
    }

    /* Chat controls use <textarea> now */
    .chat-controls {
      display: flex;
      gap: 5px;
      margin-bottom: 20px; 
    }
    textarea {
      padding: 8px;
      box-sizing: border-box;
      resize: none; /* We'll do auto-resize in JS */
      width: 100%;
      height: auto;
      min-height: 40px;
      max-height: 200px;
      overflow-y: auto;
    }
    button {
      padding: 8px;
      cursor: pointer;
    }

    .username-input,
    .enter-chat-btn {
      width: 100% !important;
      margin-top: 8px;
    }

    /* ----------------------------------------
       2) Dark Mode
       ---------------------------------------- */
    body.dark-mode {
      background: #111;
      color: #eee;
    }
    body.dark-mode #loginDiv,
    body.dark-mode #chatDiv,
    body.dark-mode #settingsDiv {
      background: #222;
      color: #eee;
    }
    body.dark-mode textarea {
      background: #333;
      color: #eee;
      border: 1px solid #444;
    }
    body.dark-mode button {
      background: #444;
      color: #eee;
      border: 1px solid #666;
    }
    body.dark-mode select {
      background: #333;
      color: #eee;
      border: 1px solid #444;
    }

    /* ----------------------------------------
       3) Custom Font Classes
       ---------------------------------------- */
    .font-arial {
      font-family: Arial, sans-serif;
    }
    .font-georgia {
      font-family: Georgia, serif;
    }
    .font-courier {
      font-family: "Courier New", Courier, monospace;
    }
    .font-comic {
      font-family: "Comic Sans MS", cursive, sans-serif;
    }
    .font-roboto {
      font-family: "Roboto", sans-serif;
    }
    .font-times {
      font-family: "Times New Roman", Times, serif;
    }
    .font-verdana {
      font-family: Verdana, sans-serif;
    }
    .font-trebuchet {
      font-family: "Trebuchet MS", Helvetica, sans-serif;
    }
    .font-lucida {
      font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
    }
    .font-garamond {
      font-family: Garamond, serif;
    }

    /* ----------------------------------------
       4) Message Animation
       ---------------------------------------- */
    @keyframes message-enter {
      0% {
        transform: scale(0.8);
        opacity: 0;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
    .message-enter {
      animation: message-enter 0.3s ease forwards;
    }

    /* ----------------------------------------
       5) DM Section (Multiple DMs)
       ---------------------------------------- */
    #dmSection {
      margin-top: 20px;
      border-top: 1px solid #ccc;
      padding-top: 10px;
    }
    /* Each DM box gets its own messages container */
    #dmMessages, #dm2Messages, #dm3Messages {
      list-style-type: none;
      padding: 0;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 10px;
      border: 1px solid #ddd;
    }
    #dmMessages li, #dm2Messages li, #dm3Messages li {
      padding: 8px;
      border-bottom: 1px solid #eee;
      margin: 0 4px;
    }
    .dm-controls {
      display: flex;
      gap: 5px;
    }

    /* ----------------------------------------
       Tutorial box styling
       ---------------------------------------- */
    .tutorial-box {
      margin-bottom:10px; 
      font-size: 0.9em; 
      background:#fafafa; 
      padding:6px; 
      border-radius:5px;
      transition: background 0.3s, color 0.3s;
    }
    body.dark-mode .tutorial-box {
      background: #333;
      color: #eee;
    }

    /* ----------------------------------------
       7) Changelog Overlay
       (Always shows on page load)
       ---------------------------------------- */
    #changelogOverlay {
      position: fixed;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      display: none; 
      justify-content: center;
      align-items: center;
      z-index: 9999; 
    }
    #changelogModal {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      max-width: 400px;
      width: 90%;
      color: #000;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #changelogModal h2 {
      margin-top: 0;
    }
    #changelogModal ul {
      margin: 10px 0;
      padding-left: 20px;
    }
    #changelogModal button {
      margin-top: 10px;
    }

  </style>
</head>
<body>

  <!-- ===============================
       CHANGELOG POPUP (ALWAYS SHOWS)
       =============================== -->
  <div id="changelogOverlay">
    <div id="changelogModal">
      <h2>Changelog (v1.2.0)</h2>
      <ul>
        <li>Fixed group chat bug (no more public chat leaking into private group).</li>
        <li>Leaving a group does not remove public chat anymore.</li>
        <li>Added multiple direct message boxes</li>
      </ul>
      <button onclick="closeChangelog()">Close</button>
    </div>
  </div>

  <!-- ===============================
       1) LOGIN SCREEN (loginDiv)
       =============================== -->
  <div id="loginDiv">
    <h2>Enter Chat</h2>
    <p>Anonymous / Temporary Name:</p>
    <!-- If user is logged in, this becomes read-only -->
    <input type="text" id="anonymousInput" class="username-input" placeholder="Anonymous Name" />
    <button onclick="startChatting()" class="enter-chat-btn">Start Chatting</button>

    <hr />
    <!-- Account Management (Username + Password) -->
    <h3>Account</h3>
    <div id="notLoggedInUI">
      <input type="text" id="accNameInput" placeholder="Desired username" style="width:100%; margin-bottom:5px;" />
      <input type="text" id="accPassInput" placeholder="Password" style="width:100%; margin-bottom:5px;" />
      <button onclick="createOrLoginAccount()">Create/Login Account</button>
    </div>

    <div id="loggedInUI" style="display:none;">
      <p>Logged in as: <span id="loggedInName"></span></p>

      <!-- Rename Account -->
      <input type="text" id="renameInput" placeholder="New username" style="width:100%; margin-bottom:5px;" />
      <button onclick="renameAccount()">Rename Account</button>
      <br /><br />

      <!-- Change Password -->
      <input type="text" id="changePassInput" placeholder="New Password" style="width:100%; margin-bottom:5px;" />
      <button onclick="changePassword()">Change Password</button>
      <br /><br />

      <button onclick="logOutAccount()">Log Out</button>
    </div>

    <hr />
    <!-- Settings button is only here, in the main screen -->
    <button onclick="showSettingsFromLogin()">Settings</button>

    <!-- ===============================
         OP-ONLY SECTION (MAIN MENU BOTTOM)
         =============================== -->
    <div id="opSection" style="display:none; margin-top: 20px; border-top:1px solid #ccc; padding-top:10px;">
      <h3>OP Tools</h3>
      <!-- Clear Chat Button -->
      <button onclick="clearChatForEveryone()" style="background:#e00; color:#fff;">Clear Chat (Server-Side)</button>
      <br /><br />

      <!-- Broadcast -->
      <label for="opBroadcastInput">Broadcast Message (shown to all):</label><br/>
      <input type="text" id="opBroadcastInput" style="width:100%; margin-bottom:5px;" />
      <button onclick="sendBroadcast()" style="background:#2196F3; color:#fff;">Send Broadcast</button>
      <br /><br />

      <!-- Color Picker (Optional) -->
      <label for="opColorPicker">Change Your Name Color:</label><br/>
      <input type="color" id="opColorPicker" value="#4A94DA" />
      <button onclick="setOpColor()">Set Name Color</button>
      <br /><br />

      <!-- Debug button to clear all 'typing' states -->
      <button onclick="clearAllTyping()" style="background:#9c27b0; color:#fff;">Clear All 'Typing' (Server-Side)</button>
    </div>
  </div>

  <!-- ================================
       2) CHAT SCREEN (chatDiv)
       ================================ -->
  <div id="chatDiv">
    <h2>Yap Room</h2>

    <!-- Quick list of room commands (OP commands hidden) -->
    <div class="tutorial-box">
      <strong>Group Chat Commands:</strong><br/>
      /createroom [roomName]<br/>
      /join [roomName]<br/>
      /invite [accountName]<br/>
      /leave
    </div>

    <!-- A) Messages + "Who is typing" indicator -->
    <ul id="messages"></ul>
    <div id="typingStatus"></div>

    <div class="chat-controls">
      <textarea id="messageInput" placeholder="Type a message" oninput="handleTyping()"></textarea>
      <button onclick="sendMessage()">Send</button>
      <button onclick="clearChat()">Clear Chat</button>
    </div>

    <!-- 2B) Direct Messages Section (MULTIPLE DM BOXES) -->
    <div id="dmSection">
      <h3>Direct Messages</h3>
      <div id="dmLoginWarning" style="color:red; display:none;">
        You must be logged in to use DMs.
      </div>
      <div id="dmUI" style="display:none;">
        <!-- DM #1 -->
        <p><strong>DM #1</strong> – Type a single username to DM:</p>
        <input type="text" id="dmTargetInput" placeholder="username to DM" style="width:100%; margin-bottom:5px;" />
        <button onclick="openDM()">Open DM</button>

        <div id="dmConversation" style="margin-top:10px; display:none;">
          <ul id="dmMessages"></ul>
          <div class="dm-controls">
            <textarea id="dmMessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
            <button onclick="sendDM()">Send DM</button>
          </div>
        </div>

        <hr/>

        <!-- DM #2 -->
        <p><strong>DM #2</strong> – Type a single username to DM:</p>
        <input type="text" id="dm2TargetInput" placeholder="username to DM" style="width:100%; margin-bottom:5px;" />
        <button onclick="openDM2()">Open DM #2</button>

        <div id="dm2Conversation" style="margin-top:10px; display:none;">
          <ul id="dm2Messages"></ul>
          <div class="dm-controls">
            <textarea id="dm2MessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
            <button onclick="sendDM2()">Send DM #2</button>
          </div>
        </div>

        <hr/>

        <!-- DM #3 -->
        <p><strong>DM #3</strong> – Type a single username to DM:</p>
        <input type="text" id="dm3TargetInput" placeholder="username to DM" style="width:100%; margin-bottom:5px;" />
        <button onclick="openDM3()">Open DM #3</button>

        <div id="dm3Conversation" style="margin-top:10px; display:none;">
          <ul id="dm3Messages"></ul>
          <div class="dm-controls">
            <textarea id="dm3MessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
            <button onclick="sendDM3()">Send DM #3</button>
          </div>
        </div>
      </div>
    </div>

    <!-- 2C) Return to Main Screen -->
    <div style="margin-top:20px; text-align:center;">
      <button onclick="returnToLogin()">Return to Main Screen</button>
    </div>
  </div>

  <!-- ================================
       3) SETTINGS SCREEN (settingsDiv)
       ================================ -->
  <div id="settingsDiv">
    <h2>Settings</h2>
    <label>
      <input type="checkbox" id="themeToggle" onchange="toggleDarkMode()" />
      Dark Mode
    </label>
    <br><br>

    <label for="guiSizeRange">GUI Size</label>
    <input type="range" id="guiSizeRange" min="0.5" max="2.0" step="0.1" value="1.0" onchange="updateGuiSize()" />
    <p id="guiSizeValue"></p>

    <label for="fontSelect">Choose Font:</label>
    <select id="fontSelect" onchange="updateFont()">
      <option value="font-arial">Arial</option>
      <option value="font-georgia">Georgia</option>
      <option value="font-courier">Courier New</option>
      <option value="font-comic">Comic Sans MS</option>
      <option value="font-roboto">Roboto</option>
      <option value="font-times">Times New Roman</option>
      <option value="font-verdana">Verdana</option>
      <option value="font-trebuchet">Trebuchet MS</option>
      <option value="font-lucida">Lucida Sans Unicode</option>
      <option value="font-garamond">Garamond</option>
    </select>
    <br><br>

    <!-- Notification toggle -->
    <label>
      <input type="checkbox" id="notificationsToggle" onchange="toggleNotifications()" />
      Enable Desktop Notifications
    </label>
    <br><br>

    <button onclick="goBack()">Back</button>
  </div>

  <!-- ---------------------------------
       Firebase SDK (Compat versions)
       --------------------------------->
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-database-compat.js"></script>

  <!-- SHA-256 library for hashing passwords -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>

  <script>
    /* =====================================================
       1) Firebase Configuration & Initialization
       (DO NOT CHANGE THESE KEYS)
       ===================================================== */
    const firebaseConfig = {
      apiKey: "AIzaSyBkm5Lf3PaghllqcatG_FymhTm_x7mGa28",
      authDomain: "yaproom-14cfe.firebaseapp.com",
      databaseURL: "https://yaproom-14cfe-default-rtdb.firebaseio.com",
      projectId: "yaproom-14cfe",
      storageBucket: "yaproom-14cfe.firebaseapp.com",
      messagingSenderId: "5332542311",
      appId: "1:5332542311:web:f1a1ab2fb81bf62b0b45c2"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    /* =====================================================
       2) Global Variables & OP List
       ===================================================== */
    const OP_LIST = ["god", "nubunknown", "pasta"];  // Hidden commands, but still recognized for OP usage

    let lastMessageTime = 0;
    const RATE_LIMIT_MS = 2000; // 2-second limit
    const badWords = ["shit","fuck","bitch","nigga","fucking","shitting","negro","bullshit","pussy"];

    let currentUsername = null;
    let currentPassHash = null;

    // For account deletion listening
    let accountDeletedRef = null;  // We'll store a reference to detach later

    // For DM #1
    let currentDMPath = null;
    let dmListener = null;

    // For DM #2
    let currentDM2Path = null;
    let dm2Listener = null;

    // For DM #3
    let currentDM3Path = null;
    let dm3Listener = null;

    // Group Chat 
    let inGroupChat = false;
    let currentGroupRoomName = null;
    let groupListener = null;

    // Typing
    let typingTimeout = null;

    // Mute system
    let mutedUsers = {};

    // OP color system
    let accountColors = {};

    // We'll store all public messages here so we can re-show them after leaving a group.
    let publicMessages = [];
    let publicListenerAdd = null;
    let publicListenerRemove = null;

    /* =====================================================
       3) On Page Load: Always show Changelog
       ===================================================== */
    window.onload = function() {
      document.getElementById("changelogOverlay").style.display = "flex";

      // A) Dark Mode
      const darkModeEnabled = localStorage.getItem("darkModeEnabled") === "true";
      if (darkModeEnabled) document.body.classList.add("dark-mode");
      document.getElementById("themeToggle").checked = darkModeEnabled;

      // B) GUI Size
      const savedScale = localStorage.getItem("uiScale");
      if (savedScale) {
        document.documentElement.style.fontSize = (16 * savedScale) + "px";
        document.getElementById("guiSizeRange").value = savedScale;
      }
      updateGuiSizeDisplay();

      // C) Font
      const savedFont = localStorage.getItem("selectedFont") || "font-arial";
      document.body.classList.add(savedFont);
      document.getElementById("fontSelect").value = savedFont;

      // D) Account
      currentUsername = localStorage.getItem("acc_username");
      currentPassHash = localStorage.getItem("acc_passHash");
      updateAccountUI();

      // E) Start listening to public chat
      startPublicChatListeners();

      // F) Listen for typed updates
      db.ref("typing").on("value", (snap) => {
        const typingObj = snap.val() || {};
        showTypingStatus(typingObj);
      });

      // G) Listen for muted users
      db.ref("mutedUsers").on("value", (snap) => {
        mutedUsers = snap.val() || {};
      });

      // H) Listen for account colors
      db.ref("accountColors").on("value", (snap) => {
        accountColors = snap.val() || {};
      });

      // I) Listen for OP broadcasts
      db.ref("broadcasts").on("child_added", (snap) => {
        const bData = snap.val();
        displayMessage(bData.user, bData.text, true, true, snap.key); 
      });
      db.ref("broadcasts").on("child_removed", (snap) => {
        const removedKey = snap.key;
        const li = document.querySelector(`li[data-key="${removedKey}"]`);
        if (li) li.remove();
      });

      // SHIFT+ENTER for main chat
      const msgInput = document.getElementById("messageInput");
      msgInput.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      msgInput.addEventListener("input", autoResize);

      // SHIFT+ENTER for DM #1
      const dmInput = document.getElementById("dmMessageInput");
      dmInput.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendDM();
        }
      });
      dmInput.addEventListener("input", autoResize);

      // SHIFT+ENTER for DM #2
      const dm2Input = document.getElementById("dm2MessageInput");
      dm2Input.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendDM2();
        }
      });
      dm2Input.addEventListener("input", autoResize);

      // SHIFT+ENTER for DM #3
      const dm3Input = document.getElementById("dm3MessageInput");
      dm3Input.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendDM3();
        }
      });
      dm3Input.addEventListener("input", autoResize);

      // J) Notifications Setting
      const notificationsEnabled = localStorage.getItem("notificationsEnabled") === "true";
      const notificationsToggle = document.getElementById("notificationsToggle");
      if (notificationsToggle) {
        notificationsToggle.checked = notificationsEnabled;
      }

      // Also remove "typing" if user closes the tab/window
      window.onbeforeunload = function() {
        removeUserTyping();
      };
    };

    /* Close the changelog overlay */
    function closeChangelog() {
      document.getElementById("changelogOverlay").style.display = "none";
    }

    /* Auto-resize logic for textareas */
    function autoResize(event) {
      const textarea = event.target;
      textarea.style.height = "auto";
      textarea.style.height = (textarea.scrollHeight) + "px";
    }

    /* =====================================================
       PUBLIC CHAT LISTENER
       ===================================================== */
    function startPublicChatListeners() {
      // Remove old listeners if any
      db.ref("messages").off("child_added", publicListenerAdd);
      db.ref("messages").off("child_removed", publicListenerRemove);
      publicMessages = [];
      document.getElementById("messages").innerHTML = "";

      // Listen for new public messages
      publicListenerAdd = db.ref("messages").on("child_added", (snapshot) => {
        const msg = snapshot.val();
        const key = snapshot.key;
        // If user is muted, skip
        if (msg.user && mutedUsers[msg.user.toLowerCase()]) return;

        publicMessages.push({ key, ...msg });
        // Only display if we are NOT in a group
        if (!inGroupChat) {
          displayMessage(msg.user, msg.text, msg.isAccount, false, key);
        }
      });

      // Listen for removed public messages
      publicListenerRemove = db.ref("messages").on("child_removed", (snap) => {
        const removedKey = snap.key;
        // Remove from array
        publicMessages = publicMessages.filter(m => m.key !== removedKey);

        // If we're currently in public mode, remove from UI
        if (!inGroupChat) {
          const li = document.querySelector(`li[data-key="${removedKey}"]`);
          if (li) li.remove();
        }
      });
    }

    /* =====================================================
       4) Account Creation / Login
       ===================================================== */
    async function createOrLoginAccount() {
      const desiredName = document.getElementById("accNameInput").value.trim().toLowerCase();
      const desiredPass = document.getElementById("accPassInput").value.trim();
      if (!desiredName || !desiredPass) {
        alert("Please provide both a username and a password.");
        return;
      }
      const passHash = sha256(desiredPass);

      try {
        const snap = await db.ref("accounts/" + desiredName).once("value");
        if (!snap.exists()) {
          // Create new account
          await db.ref("accounts/" + desiredName).set({
            passwordHash: passHash,
            createdAt: Date.now()
          });
          alert("Account created! Logged in as: " + desiredName);
        } else {
          // Existing account, verify password
          const data = snap.val();
          if (data.passwordHash !== passHash) {
            alert("Incorrect password or name is taken by someone else.");
            return;
          }
          alert("Logged in successfully as: " + desiredName);
        }
        currentUsername = desiredName;
        currentPassHash = passHash;
        localStorage.setItem("acc_username", currentUsername);
        localStorage.setItem("acc_passHash", currentPassHash);
        updateAccountUI();
      } catch (err) {
        alert("Error creating/logging in: " + err);
      }
    }

    function updateAccountUI() {
      const notLoggedInUI = document.getElementById("notLoggedInUI");
      const loggedInUI = document.getElementById("loggedInUI");
      const loggedInName = document.getElementById("loggedInName");
      const anonInput = document.getElementById("anonymousInput");

      if (currentUsername && currentPassHash) {
        notLoggedInUI.style.display = "none";
        loggedInUI.style.display = "block";
        loggedInName.textContent = currentUsername;

        // Make the "anonymous name" box read-only
        anonInput.value = currentUsername;
        anonInput.disabled = true;

        // Listen for account deletion in real-time
        listenForAccountDeletion();
      } else {
        notLoggedInUI.style.display = "block";
        loggedInUI.style.display = "none";
        anonInput.value = "";
        anonInput.disabled = false;

        // Stop listening if we logged out
        if (accountDeletedRef) {
          accountDeletedRef.off("value");
          accountDeletedRef = null;
        }
      }
      updateDMUI();
      checkIfOP();
    }

    /* Force-logout if the account is removed from DB */
    function listenForAccountDeletion() {
      // If we had an old reference, detach it
      if (accountDeletedRef) {
        accountDeletedRef.off("value");
        accountDeletedRef = null;
      }
      if (!currentUsername) return;

      // Listen to "accounts/[username]" 
      accountDeletedRef = db.ref("accounts/" + currentUsername);
      accountDeletedRef.on("value", (snap) => {
        // If the snapshot doesn't exist, the account was removed => forcibly log out
        if (!snap.exists()) {
          alert("Your account has been terminated!");
          // forcibly log out
          logOutAccount();
        }
      });
    }

    async function logOutAccount() {
      removeUserTyping();

      // Remove account deletion listener if it exists
      if (accountDeletedRef) {
        accountDeletedRef.off("value");
        accountDeletedRef = null;
      }

      localStorage.removeItem("acc_username");
      localStorage.removeItem("acc_passHash");
      currentUsername = null;
      currentPassHash = null;
      alert("Logged out.");

      updateAccountUI();
    }

    /* Remove current user's "typing" ref from DB */
    function removeUserTyping() {
      if (currentUsername) {
        db.ref("typing/" + currentUsername).remove();
      }
    }

    /* =====================================================
       5) Rename Account
       ===================================================== */
    async function renameAccount() {
      if (!currentUsername || !currentPassHash) {
        alert("You are not logged in, can't rename.");
        return;
      }
      const newName = document.getElementById("renameInput").value.trim().toLowerCase();
      if (!newName) {
        alert("Enter a new username.");
        return;
      }
      // Check if taken
      const snap = await db.ref("accounts/" + newName).once("value");
      if (snap.exists()) {
        alert("That username is taken.");
        return;
      }
      try {
        // remove old
        await db.ref("accounts/" + currentUsername).remove();
        // create new
        await db.ref("accounts/" + newName).set({
          passwordHash: currentPassHash,
          createdAt: Date.now()
        });
        // remove old typing
        db.ref("typing/" + currentUsername).remove();

        currentUsername = newName;
        localStorage.setItem("acc_username", currentUsername);
        alert("Renamed to " + newName);
        updateAccountUI();
      } catch (err) {
        alert("Error renaming: " + err);
      }
    }

    /* =====================================================
       5B) Change Password
       ===================================================== */
    async function changePassword() {
      if (!currentUsername || !currentPassHash) {
        alert("You are not logged in, can't change password.");
        return;
      }
      const newPass = document.getElementById("changePassInput").value.trim();
      if (!newPass) {
        alert("Enter a new password.");
        return;
      }
      const newPassHash = sha256(newPass);

      try {
        await db.ref("accounts/" + currentUsername).update({
          passwordHash: newPassHash
        });
        currentPassHash = newPassHash;
        localStorage.setItem("acc_passHash", newPassHash);
        alert("Password changed successfully!");
        document.getElementById("changePassInput").value = "";
      } catch (err) {
        alert("Error changing password: " + err);
      }
    }

    /* =====================================================
       6) Starting the Chat
       ===================================================== */
    function startChatting() {
      if (!currentUsername) {
        const anonName = document.getElementById("anonymousInput").value.trim();
        if (!anonName) {
          alert("Please enter a name or create an account.");
          return;
        }
        currentUsername = anonName;
      }
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("chatDiv").style.display = "block";
      updateDMUI();
    }

    /* =====================================================
       7) Public Chat
       ===================================================== */
    function filterBadWords(text) {
      const badWordsLower = badWords.map(word => word.toLowerCase());
      let filtered = text;
      badWordsLower.forEach(word => {
        const regex = new RegExp("\\b" + word + "\\b", "gi");
        filtered = filtered.replace(regex, "****");
      });
      return filtered;
    }

    function sendMessage() {
      const inp = document.getElementById("messageInput");
      let text = inp.value.trim();
      if (!text) return;

      if (text.startsWith("/")) {
        handleSlashCommand(text);
        inp.value = "";
        inp.style.height = "40px";
        return;
      }

      // Rate limit
      const currentTime = Date.now();
      if (currentTime - lastMessageTime < RATE_LIMIT_MS) {
        const secLeft = Math.ceil((RATE_LIMIT_MS - (currentTime - lastMessageTime)) / 1000);
        alert(`Wait ${secLeft} second(s).`);
        return;
      }

      // Mute check
      if (currentUsername && mutedUsers[currentUsername.toLowerCase()]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }

      text = filterBadWords(text);

      let finalName = currentUsername || "Unknown";
      const isAccount = (currentUsername && currentPassHash);

      if (inGroupChat && currentGroupRoomName) {
        // Group chat
        db.ref("groupRooms/" + currentGroupRoomName + "/messages").push({
          user: finalName,
          text: text,
          timestamp: firebase.database.ServerValue.TIMESTAMP
        });
      } else {
        // Public chat
        db.ref("messages").push({
          user: finalName,
          text: text,
          isAccount: isAccount,
          timestamp: firebase.database.ServerValue.TIMESTAMP
        });
      }

      inp.value = "";
      inp.style.height = "40px";
      lastMessageTime = currentTime;

      if (currentUsername) {
        db.ref("typing/" + currentUsername).remove();
      }
    }

    function displayMessage(user, text, isAccount, isBroadcast, messageKey) {
      const ul = document.getElementById("messages");
      const li = document.createElement("li");
      li.classList.add("message-enter");

      if (messageKey) {
        li.setAttribute("data-key", messageKey);
      }

      let userColorClass = isAccount ? "account-user" : "anonymous-user";
      let colorStyle = "";

      if (accountColors[user?.toLowerCase()]) {
        colorStyle = `style="color:${accountColors[user.toLowerCase()]}; font-weight:bold;"`;
      } else if (isAccount) {
        colorStyle = `style="color:rgb(74, 148, 218);"`;
      }

      if (isBroadcast) {
        li.innerHTML = `<span class="broadcast-msg">[BROADCAST from ${user}]</span> ${text}`;
      } else {
        li.innerHTML = `<span class="${userColorClass}" ${colorStyle}>${user}</span>: ${text}`;
      }

      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function clearChat() {
      const confirmClear = confirm("Are you sure you want to clear the chat messages **on your screen**?");
      if (!confirmClear) return;
      document.getElementById("messages").innerHTML = "";
    }

    /* =====================================================
       8) Typing Indicators (Main Chat)
       ===================================================== */
    function handleTyping() {
      if (!currentUsername) return;
      db.ref("typing/" + currentUsername).set(true);
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        db.ref("typing/" + currentUsername).remove();
      }, 3000);
    }

    function showTypingStatus(typingObj) {
      const keys = Object.keys(typingObj).filter((u) => u !== currentUsername);
      const typingDiv = document.getElementById("typingStatus");
      if (keys.length === 0) {
        typingDiv.textContent = "";
      } else if (keys.length === 1) {
        typingDiv.textContent = `${keys[0]} is typing...`;
      } else {
        typingDiv.textContent = `${keys.join(", ")} are typing...`;
      }
    }

    /* =====================================================
       9) Multiple DM Support
       ===================================================== */
    function updateDMUI() {
      const warn = document.getElementById("dmLoginWarning");
      const ui = document.getElementById("dmUI");
      if (currentUsername && currentPassHash) {
        warn.style.display = "none";
        ui.style.display = "block";
      } else {
        warn.style.display = "block";
        ui.style.display = "none";
      }
    }

    // ---------------------------
    // DM #1
    // ---------------------------
    function openDM() {
      const typedName = document.getElementById("dmTargetInput").value.trim().toLowerCase();
      if (!typedName) {
        alert("Please type a username to DM.");
        return;
      }
      if (!currentUsername || !currentPassHash) {
        alert("You must be logged in to DM.");
        return;
      }

      // Remove old DM listener if any
      if (dmListener && currentDMPath) {
        db.ref(currentDMPath).off("child_added", dmListener);
      }

      const userA = currentUsername.toLowerCase();
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDMPath = "dms/" + dmKey;

      document.getElementById("dmMessages").innerHTML = "";
      document.getElementById("dmConversation").style.display = "block";

      dmListener = db.ref(currentDMPath).on("child_added", (snap) => {
        const val = snap.val();
        displayDMMessage(val.user, val.text);

        // Show notification if it's not our own message
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
        }
      });
    }

    function displayDMMessage(sender, text) {
      const ul = document.getElementById("dmMessages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM() {
      if (!currentDMPath) {
        alert("No DM open. Type a username and 'Open DM' first.");
        return;
      }
      const inp = document.getElementById("dmMessageInput");
      let text = inp.value.trim();
      if (!text) return;

      text = filterBadWords(text);

      if (currentUsername && mutedUsers[currentUsername.toLowerCase()]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }

      const finalName = currentUsername || "Unknown";
      db.ref(currentDMPath).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px"; 
    }

    // ---------------------------
    // DM #2
    // ---------------------------
    function openDM2() {
      const typedName = document.getElementById("dm2TargetInput").value.trim().toLowerCase();
      if (!typedName) {
        alert("Please type a username to DM (DM #2).");
        return;
      }
      if (!currentUsername || !currentPassHash) {
        alert("You must be logged in to DM.");
        return;
      }

      // Remove old DM listener if any
      if (dm2Listener && currentDM2Path) {
        db.ref(currentDM2Path).off("child_added", dm2Listener);
      }

      const userA = currentUsername.toLowerCase();
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDM2Path = "dms/" + dmKey;

      document.getElementById("dm2Messages").innerHTML = "";
      document.getElementById("dm2Conversation").style.display = "block";

      dm2Listener = db.ref(currentDM2Path).on("child_added", (snap) => {
        const val = snap.val();
        displayDM2Message(val.user, val.text);

        // Show notification if it's not our own message
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
        }
      });
    }

    function displayDM2Message(sender, text) {
      const ul = document.getElementById("dm2Messages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM2() {
      if (!currentDM2Path) {
        alert("No DM #2 open. Type a username and 'Open DM #2' first.");
        return;
      }
      const inp = document.getElementById("dm2MessageInput");
      let text = inp.value.trim();
      if (!text) return;

      text = filterBadWords(text);

      if (currentUsername && mutedUsers[currentUsername.toLowerCase()]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }

      const finalName = currentUsername || "Unknown";
      db.ref(currentDM2Path).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px"; 
    }

    // ---------------------------
    // DM #3
    // ---------------------------
    function openDM3() {
      const typedName = document.getElementById("dm3TargetInput").value.trim().toLowerCase();
      if (!typedName) {
        alert("Please type a username to DM (DM #3).");
        return;
      }
      if (!currentUsername || !currentPassHash) {
        alert("You must be logged in to DM.");
        return;
      }

      // Remove old DM listener if any
      if (dm3Listener && currentDM3Path) {
        db.ref(currentDM3Path).off("child_added", dm3Listener);
      }

      const userA = currentUsername.toLowerCase();
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDM3Path = "dms/" + dmKey;

      document.getElementById("dm3Messages").innerHTML = "";
      document.getElementById("dm3Conversation").style.display = "block";

      dm3Listener = db.ref(currentDM3Path).on("child_added", (snap) => {
        const val = snap.val();
        displayDM3Message(val.user, val.text);

        // Show notification if it's not our own message
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
        }
      });
    }

    function displayDM3Message(sender, text) {
      const ul = document.getElementById("dm3Messages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM3() {
      if (!currentDM3Path) {
        alert("No DM #3 open. Type a username and 'Open DM #3' first.");
        return;
      }
      const inp = document.getElementById("dm3MessageInput");
      let text = inp.value.trim();
      if (!text) return;

      text = filterBadWords(text);

      if (currentUsername && mutedUsers[currentUsername.toLowerCase()]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }

      const finalName = currentUsername || "Unknown";
      db.ref(currentDM3Path).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px"; 
    }

    /* =====================================================
       10) Group Chat (Slash Commands)
       ===================================================== */
    async function handleSlashCommand(text) {
      const parts = text.split(" ");
      const cmd = parts[0].toLowerCase(); 
      const arg = parts[1] ? parts[1].trim().toLowerCase() : null;

      // OP commands (hidden from tutorial, but still functional for OPs)
      if (isCurrentUserOP()) {
        if (cmd === "/mute" || cmd === "/unmute") {
          handleOpCommand(cmd, arg);
          return;
        }
        if (cmd === "/terminate") {
          if (!arg) {
            alert("Usage: /terminate [accountName]");
          } else {
            terminateAccount(arg);
          }
          return;
        }
      }

      // Regular group commands
      switch(cmd) {
        case "/createroom":
          if (!arg) {
            alert("Usage: /createroom [roomName]");
            return;
          }
          await createGroupRoom(arg);
          break;

        case "/join":
          if (!arg) {
            alert("Usage: /join [roomName]");
            return;
          }
          await joinGroupRoom(arg);
          break;

        case "/invite":
          if (!arg) {
            alert("Usage: /invite [accountName]");
            return;
          }
          await inviteToGroup(arg);
          break;

        case "/leave":
          leaveGroupRoom();
          break;

        default:
          alert("Unknown command.");
      }
    }

    async function createGroupRoom(roomName) {
      if (!currentUsername || !currentPassHash) {
        alert("You must be logged in to create a group room.");
        return;
      }
      const snap = await db.ref("groupRooms/" + roomName).once("value");
      if (snap.exists()) {
        alert("That room name already exists. Choose a different one.");
        return;
      }
      await db.ref("groupRooms/" + roomName).set({
        participants: [currentUsername.toLowerCase()],
        createdAt: Date.now(),
        messages: {
          dummy: { system: "Group created" }
        }
      });
      alert(`Group room "${roomName}" created. You are now inside it.`);
      joinGroupRoom(roomName);
    }

    async function joinGroupRoom(roomName) {
      if (!currentUsername || !currentPassHash) {
        alert("You must be logged in to join a group room.");
        return;
      }
      const snap = await db.ref("groupRooms/" + roomName).once("value");
      if (!snap.exists()) {
        alert("That room does not exist.");
        return;
      }
      const roomData = snap.val();
      const me = currentUsername.toLowerCase();
      if (!roomData.participants || !roomData.participants.includes(me)) {
        alert("You are not invited to this room. Ask someone to /invite you.");
        return;
      }

      // Turn OFF public chat display
      inGroupChat = true;
      // Clear the main messages UI
      document.getElementById("messages").innerHTML = "";

      // Stop listening to group if any
      if (groupListener) {
        db.ref("groupRooms/" + currentGroupRoomName + "/messages").off("child_added", groupListener);
      }

      currentGroupRoomName = roomName;
      groupListener = db.ref("groupRooms/" + roomName + "/messages").on("child_added", (snapMsg) => {
        const val = snapMsg.val();
        if (val.user && val.text) {
          if (mutedUsers[val.user.toLowerCase()]) return;
          displayMessage(val.user, val.text, true, false, snapMsg.key);
        } else if (val.system) {
          displayMessage("System", val.system, false, false, snapMsg.key);
        }
      });

      alert(`You joined group room "${roomName}". All your new messages will now go there.`);
    }

    async function inviteToGroup(accountName) {
      if (!inGroupChat || !currentGroupRoomName) {
        alert("You are not in a group room. Use /join [roomName] first.");
        return;
      }
      const roomRef = db.ref("groupRooms/" + currentGroupRoomName + "/participants");
      const snap = await roomRef.once("value");
      const participants = snap.val() || [];
      if (!participants.includes(accountName)) {
        participants.push(accountName);
      }
      await roomRef.set(participants);
      db.ref("groupRooms/" + currentGroupRoomName + "/messages").push({
        system: `${accountName} has been invited.`
      });
      alert(`${accountName} invited to "${currentGroupRoomName}".`);
    }

    function leaveGroupRoom() {
      if (!inGroupChat) {
        alert("You are not in a group room.");
        return;
      }
      // Remove group listener
      if (groupListener && currentGroupRoomName) {
        db.ref("groupRooms/" + currentGroupRoomName + "/messages").off("child_added", groupListener);
      }

      // Clear UI
      document.getElementById("messages").innerHTML = "";
      inGroupChat = false;
      currentGroupRoomName = null;

      // We are back to public chat mode
      // Re-show all stored public messages
      publicMessages.forEach(msg => {
        displayMessage(msg.user, msg.text, msg.isAccount, false, msg.key);
      });

      alert("You left the group room. You are back to public chat.");
    }

    /* =====================================================
       11) OP Commands & Tools
       ===================================================== */
    function isCurrentUserOP() {
      return currentUsername && OP_LIST.includes(currentUsername.toLowerCase());
    }

    function checkIfOP() {
      const opSection = document.getElementById("opSection");
      if (isCurrentUserOP()) {
        opSection.style.display = "block";
      } else {
        opSection.style.display = "none";
      }
    }

    function handleOpCommand(cmd, target) {
      if (!target) {
        alert("Usage: " + cmd + " [username]");
        return;
      }
      if (cmd === "/mute") {
        db.ref("mutedUsers/" + target).set(true);
        alert(`User "${target}" has been muted.`);
      } else if (cmd === "/unmute") {
        db.ref("mutedUsers/" + target).remove();
        alert(`User "${target}" has been unmuted.`);
      }
    }

    // Permanently terminate an account + all signs of them
    async function terminateAccount(target) {
      const confirmTerm = confirm(`Are you sure you want to TERMINATE the account "${target}"? This is permanent!`);
      if (!confirmTerm) return;
      try {
        // Remove from /accounts
        await db.ref("accounts/" + target).remove();
        // Remove from /accountColors, /typing, /mutedUsers
        await db.ref("accountColors/" + target).remove();
        await db.ref("typing/" + target).remove();
        await db.ref("mutedUsers/" + target).remove();

        // Remove from public chat messages
        const msgsSnap = await db.ref("messages").once("value");
        msgsSnap.forEach((childSnap) => {
          const val = childSnap.val();
          if (val.user && val.user.toLowerCase() === target.toLowerCase()) {
            childSnap.ref.remove();
          }
        });

        // Remove from DMs
        const dmsSnap = await db.ref("dms").once("value");
        dmsSnap.forEach((dmRoomSnap) => {
          dmRoomSnap.forEach((msgSnap) => {
            const msgVal = msgSnap.val();
            if (msgVal.user && msgVal.user.toLowerCase() === target.toLowerCase()) {
              msgSnap.ref.remove();
            }
          });
        });

        // Remove from groupRooms
        const groupsSnap = await db.ref("groupRooms").once("value");
        groupsSnap.forEach((roomSnap) => {
          const roomData = roomSnap.val();
          if (!roomData) return;
          // Remove from participants
          if (roomData.participants) {
            const updated = roomData.participants.filter(p => p.toLowerCase() !== target.toLowerCase());
            if (updated.length !== roomData.participants.length) {
              roomSnap.ref.child("participants").set(updated);
            }
          }
          // Remove any messages from that user
          if (roomData.messages) {
            Object.keys(roomData.messages).forEach((mKey) => {
              const mVal = roomData.messages[mKey];
              if (mVal.user && mVal.user.toLowerCase() === target.toLowerCase()) {
                roomSnap.ref.child("messages").child(mKey).remove();
              }
            });
          }
        });

        alert(`Account "${target}" has been TERMINATED. That user is now forcefully logged out (if they were online).`);
      } catch (err) {
        alert("Error terminating account: " + err);
      }
    }

    async function clearChatForEveryone() {
      const confirmClear = confirm("Are you sure you want to clear the entire public chat AND all broadcasts for EVERYONE?");
      if (!confirmClear) return;
      await db.ref("messages").remove();
      await db.ref("broadcasts").remove();
      document.getElementById("messages").innerHTML = "";
      publicMessages = [];
      alert("All messages and broadcasts cleared for everyone.");
    }

    function sendBroadcast() {
      if (!isCurrentUserOP()) {
        alert("You are not an OP!");
        return;
      }
      const broadcastInput = document.getElementById("opBroadcastInput");
      const text = broadcastInput.value.trim();
      if (!text) return;
      db.ref("broadcasts").push({
        user: currentUsername,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      broadcastInput.value = "";
      alert("Broadcast sent!");
    }

    function setOpColor() {
      if (!isCurrentUserOP()) {
        alert("You are not an OP!");
        return;
      }
      const colorPicker = document.getElementById("opColorPicker");
      const chosenColor = colorPicker.value;
      db.ref("accountColors/" + currentUsername.toLowerCase()).set(chosenColor);
      alert("Your chat color has been updated to: " + chosenColor);
    }

    /* New debug function to clear all "typing" statuses for everyone */
    function clearAllTyping() {
      if (!isCurrentUserOP()) {
        alert("You are not an OP!");
        return;
      }
      db.ref("typing").remove();
      alert("All 'typing' statuses have been cleared for everyone.");
    }

    /* =====================================================
       12) Return to Main Screen
       ===================================================== */
    function returnToLogin() {
      // Remove from typing if you exit the chat
      removeUserTyping();

      document.getElementById("chatDiv").style.display = "none";
      document.getElementById("loginDiv").style.display = "block";
      checkIfOP();
    }

    /* =====================================================
       13) Settings Navigation
       ===================================================== */
    function showSettingsFromLogin() {
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("settingsDiv").style.display = "block";
    }

    function goBack() {
      document.getElementById("settingsDiv").style.display = "none";
      document.getElementById("loginDiv").style.display = "block";
    }

    /* =====================================================
       14) Dark Mode Toggle
       ===================================================== */
    function toggleDarkMode() {
      document.body.classList.toggle("dark-mode");
      const isDark = document.body.classList.contains("dark-mode");
      localStorage.setItem("darkModeEnabled", isDark);
    }

    /* =====================================================
       15) GUI Size
       ===================================================== */
    function updateGuiSize() {
      const scale = document.getElementById("guiSizeRange").value;
      document.documentElement.style.fontSize = (16 * scale) + "px";
      localStorage.setItem("uiScale", scale);
      updateGuiSizeDisplay();
    }

    function updateGuiSizeDisplay() {
      const val = document.getElementById("guiSizeRange").value;
      document.getElementById("guiSizeValue").textContent = `Current Scale: ${val}x`;
    }

    /* =====================================================
       16) Custom Font
       ===================================================== */
    function updateFont() {
      document.body.classList.remove(
        "font-arial",
        "font-georgia",
        "font-courier",
        "font-comic",
        "font-roboto",
        "font-times",
        "font-verdana",
        "font-trebuchet",
        "font-lucida",
        "font-garamond"
      );
      const selectedFont = document.getElementById("fontSelect").value;
      document.body.classList.add(selectedFont);
      localStorage.setItem("selectedFont", selectedFont);
    }

    /* =====================================================
       17) Desktop Notifications
       ===================================================== */
    function toggleNotifications() {
      const isChecked = document.getElementById("notificationsToggle").checked;
      localStorage.setItem("notificationsEnabled", isChecked);
      if (isChecked) {
        requestNotificationPermission();
      }
    }

    function requestNotificationPermission() {
      if (!("Notification" in window)) {
        alert("This browser does not support desktop notifications.");
        return;
      }
      if (Notification.permission !== "granted") {
        Notification.requestPermission().then((permission) => {
          if (permission !== "granted") {
            alert("You blocked notifications in your browser settings.");
            document.getElementById("notificationsToggle").checked = false;
            localStorage.setItem("notificationsEnabled", false);
          }
        });
      }
    }

    function showDMNotification(user, text) {
      const isNotificationsEnabled = localStorage.getItem("notificationsEnabled") === "true";
      if (!("Notification" in window) || !isNotificationsEnabled) return;

      // Only show if document is not in focus
      if (document.hidden && Notification.permission === "granted") {
        new Notification("New DM from " + user, {
          body: text,
          icon: "https://via.placeholder.com/50" // optional icon
        });
      }
    }
  </script>
</body>
</html>
